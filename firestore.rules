rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper function to check if user owns the document
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // SOCIAL FEATURES: Check if two users are friends
    function areFriends(userId, friendId) {
      return exists(/databases/$(database)/documents/friends/$(userId + '_' + friendId)) ||
             exists(/databases/$(database)/documents/friends/$(friendId + '_' + userId));
    }

    // SOCIAL FEATURES: Check if user can see friend's data based on privacy settings
    function canSeeData(friendId, dataType) {
      let friendshipDoc = /databases/$(database)/documents/friends/$(request.auth.uid + '_' + friendId);
      let reverseFriendshipDoc = /databases/$(database)/documents/friends/$(friendId + '_' + request.auth.uid);

      return (exists(friendshipDoc) && get(friendshipDoc).data.privacySettings[dataType] == true) ||
             (exists(reverseFriendshipDoc) && get(reverseFriendshipDoc).data.privacySettings[dataType] == true);
    }

    // Users collection
    match /users/{userId} {
      // Users can read and write their own profile
      allow read, write: if isOwner(userId);

      // Saved Searches subcollection
      match /savedSearches/{searchId} {
        // Users can read and write their own saved searches
        allow read: if isOwner(userId);
        allow create: if isOwner(userId) &&
                         request.resource.data.keys().hasAll(['id', 'name', 'query', 'filters']);
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
    }

    // Health Data collection
    match /healthData/{dataId} {
      // Allow read if user owns the data OR if friends and privacy allows
      allow read: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        (areFriends(request.auth.uid, resource.data.userId) && canSeeData(resource.data.userId, 'shareHealth'))
      );

      // Allow create if user is authenticated and creating their own data
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;

      // Allow update only for embedding fields (Cloud Functions will update these)
      allow update: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        // Allow Cloud Functions to add embedding data
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'embeddingId',
          'embeddingCreatedAt',
          'embeddingError',
          'embeddingErrorAt'
        ])
      );

      // Allow delete if user owns the data
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Location Data collection
    match /locationData/{locationId} {
      // Allow read if user owns the data OR if friends and privacy allows
      allow read: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        (areFriends(request.auth.uid, resource.data.userId) && canSeeData(resource.data.userId, 'shareLocation'))
      );

      // Allow create if user is authenticated and creating their own data
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;

      // Allow update for embedding fields and visit count
      allow update: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        // Allow Cloud Functions to add embedding data
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'embeddingId',
          'embeddingCreatedAt',
          'embeddingError',
          'embeddingErrorAt',
          'visitCount',
          'lastVisit'
        ])
      );

      // Allow delete if user owns the data
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Voice Notes collection
    match /voiceNotes/{noteId} {
      // Allow read if user owns the data
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;

      // Allow create if user is authenticated and creating their own data
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;

      // Allow update for embedding fields
      allow update: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        // Allow Cloud Functions to add embedding and transcription
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'embeddingId',
          'embeddingCreatedAt',
          'embeddingError',
          'embeddingErrorAt',
          'transcription',
          'transcriptionCreatedAt'
        ])
      );

      // Allow delete if user owns the data
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Text Notes (Diary) collection
    match /textNotes/{noteId} {
      // Allow read if user owns the data
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;

      // Allow create if user is authenticated and creating their own data
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;

      // Allow update if user owns the data OR if Cloud Functions is adding embedding
      allow update: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        // Allow Cloud Functions to add embedding fields
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'embeddingId',
          'embeddingCreatedAt',
          'embeddingError',
          'embeddingErrorAt'
        ])
      );

      // Allow delete if user owns the data
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Chat History collection
    match /chatHistory/{chatId} {
      // Allow read if user owns the data
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;

      // Allow create if user is authenticated and creating their own data
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;

      // No updates allowed (chat history is immutable)
      allow update: if false;

      // Allow delete if user owns the data
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // SOCIAL FEATURES: Friends collection
    match /friends/{friendshipId} {
      // Can read if user is one of the friends
      allow read: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        resource.data.friendUid == request.auth.uid
      );
      // Can create friendship
      allow create: if isSignedIn();
      // Can update if user is one of the friends
      allow update: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        resource.data.friendUid == request.auth.uid
      );
      // Can delete if user is one of the friends
      allow delete: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        resource.data.friendUid == request.auth.uid
      );
    }

    // SOCIAL FEATURES: Friend Requests collection
    match /friendRequests/{requestId} {
      // Can read if user is sender or recipient
      allow read: if isSignedIn() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );
      // Can create if user is the sender
      allow create: if isSignedIn() && request.resource.data.fromUserId == request.auth.uid;
      // Can update if user is the recipient (to accept/reject)
      allow update: if isSignedIn() && resource.data.toUserId == request.auth.uid;
      // Can delete if user is sender or recipient
      allow delete: if isSignedIn() && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );
    }

    // SOCIAL FEATURES: Challenges collection
    match /challenges/{challengeId} {
      // Can read if user is a participant
      allow read: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      // Can create challenge
      allow create: if isSignedIn();
      // Can update if user is the creator
      allow update: if isSignedIn() && request.auth.uid == resource.data.createdBy;
      // Can delete if user is the creator
      allow delete: if isSignedIn() && request.auth.uid == resource.data.createdBy;
    }

    // SOCIAL FEATURES: Challenge Progress collection
    match /challengeProgress/{progressId} {
      // Anyone can read progress (for leaderboards)
      allow read: if isSignedIn();
      // Only Cloud Functions can write (prevents cheating)
      allow write: if false;
    }

    // SOCIAL FEATURES: Shared Activities collection
    match /sharedActivities/{activityId} {
      // Can read if user is a participant
      allow read: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      // Can create if user is in the participant list
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      // Can update if user is a participant (for reactions/comments)
      allow update: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      // Can delete if user is a participant
      allow delete: if isSignedIn() && request.auth.uid in resource.data.participantIds;
    }

    // SOCIAL FEATURES: Feed Items collection
    match /feedItems/{feedItemId} {
      // Can read if user is friends with the activity owner
      allow read: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        areFriends(request.auth.uid, resource.data.userId)
      );
      // Only Cloud Functions can write feed items
      allow write: if false;
    }

    // Helper function to check if user has premium or pro subscription
    function hasPremiumOrPro(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      let tier = userDoc.data.subscription.tier;
      return tier == 'premium' || tier == 'pro';
    }

    // PREDICTIVE INSIGHTS: Insights collection (Premium/Pro feature)
    match /insights/{insightId} {
      // Allow read if user owns the insight AND has premium/pro subscription
      allow read: if isSignedIn() &&
        resource.data.userId == request.auth.uid &&
        hasPremiumOrPro(request.auth.uid);

      // Allow create if user is creating their own insight AND has premium/pro
      // OR allow Cloud Functions to create (they bypass these rules)
      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid &&
        hasPremiumOrPro(request.auth.uid);

      // Allow update only for dismissed and actionTaken fields (user interactions)
      allow update: if isSignedIn() &&
        resource.data.userId == request.auth.uid &&
        hasPremiumOrPro(request.auth.uid) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['dismissed', 'actionTaken']);

      // Allow delete if user owns the insight AND has premium/pro
      allow delete: if isSignedIn() &&
        resource.data.userId == request.auth.uid &&
        hasPremiumOrPro(request.auth.uid);
    }

    // Photo Memories collection
    match /photoMemories/{photoId} {
      // Allow read if user owns the photo
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;

      // Allow create if user is authenticated and creating their own photo
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;

      // Allow update for embedding fields and user description
      allow update: if isSignedIn() && (
        resource.data.userId == request.auth.uid ||
        // Allow Cloud Functions to add embedding data
        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'textEmbeddingId',
          'visualEmbeddingId',
          'embeddingCreatedAt',
          'embeddingError',
          'embeddingErrorAt',
          'userDescription',
          'tags'
        ])
      );

      // Allow delete if user owns the photo
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // Fun Facts collection
    match /fun_facts/{factId} {
      // Allow read if user owns the fun fact
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;

      // Only Cloud Functions can write fun facts (prevents tampering)
      allow write: if false;
    }

    // SUBSCRIPTIONS: Subscriptions collection
    match /subscriptions/{subscriptionId} {
      // Users can only read their own subscriptions
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;

      // Only Cloud Functions (via RevenueCat webhooks) can write subscriptions
      // Users cannot directly create/update/delete subscription records
      allow write: if false;
    }

    // SUBSCRIPTIONS: Usage tracking collection
    match /usage/{userId} {
      // Users can only read their own usage data
      allow read: if isOwner(userId);

      // Only Cloud Functions can write usage data (prevents tampering)
      allow write: if false;
    }

    // SUBSCRIPTIONS: Custom Activities subcollection (under users)
    match /users/{userId}/custom_activities/{activityId} {
      // Users can read and write their own custom activities
      allow read, write: if isOwner(userId);
    }

    // Deny all other requests by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
